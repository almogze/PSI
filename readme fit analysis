# Package imports
import xlrd
from probfit import Chi2Regression
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
from iminuit import Minuit, describe
from iminuit.util import make_func_code
from matplotlib.offsetbox import AnchoredText

warnings.simplefilter("ignore")

# Weighted Regression + Graph

file_location = r'C:\University\pycharmLab\excelCharts\SoundVelocity\Task-3.2.1.xlsx'
sheet_name = "Sheet 2"

# Defining X,Y,dx,dy axes from excel:

x_column_name = "friq"  # x column name in Excel
y_column_name = "phase"  # y column name in Excel
dx_column_name = "friq_err"  # x errors column name in Excel
dy_column_name = "phase_err"  # y errors column name in Excel

# If there's a need to take only specific indices from the data column, change here:

x_start = 0
x_stop = 10000

#  Graph Design

main_title = "Sound Velocity Measurement - 3.2.2"
x_label_title = "$\Delta$ Frequency  $[Hz]$"  # use LaTex for units symbols
y_label_title = "Phase $[\pi]$"
box_location = 4  # This is the data box that is presented on top of the graph.
# Change number here for corners: 1=top right 2=top left 3=bottom left 4=bottom right
graph_photo_name = "Sound Velocity in water measurement - 3.2.1"  # Name of exported graph photo file

# Defining the minimization:

# Function Type:
# Choose the function you want to fit to below at line 80 under func_type

# Function types in LaTex text for description at the graph box

lin_fun_text = "a\cdot x +b"
exp_fun_text = "a \cdot e^{b\cdot x}"
cos_fun_text = "a\cdot \cos(b\cdot x)"
cos2_fun_text = "a\cdot \cos(b\cdot x)^2"
poly2_fun_text = "a\cdot x^2 + b\cdot x + c"
poly3_fun_text = "a\cdot x^3 + b\cdot x^2 + c\cdot x +d"
normalised_gauss_fun_text = "\dfrac{1}{\sigma\sqrt{2\pi}} e^{-\dfrac{(x-\mu)^2}{2\sigma^2}}"
gauss_fun_text = "c\cdot e^{-\dfrac{(x-\mu)^2}{2\sigma^2}}"
normalised_poisson_fun_text = "\dfrac{\lambda^x \cdot e^{-\lambda}}{x!}"
poisson_fun_text = "c\cdot \dfrac{\lambda^x \cdot e^{-\lambda}}{x!}"

# Function types

lin_fun = lambda x, a, b: b + (x * a)
exp_fun = lambda x, a, b: a * (np.exp(b * x))
cos_fun = lambda x, a, b: a * (np.cos(b * x))
cos2_fun = lambda x, a, b: a * (np.cos(b * x)) ** 2
poly2_fun = lambda x, a, b, c: a * (x ** 2) + b * x + c
poly3_fun = lambda x, a, b, c, d: a * (x ** 3) + b * (x ** 2) + c * x + d
normalised_gauss_fun = lambda x, a, b: 1 / a * (np.sqrt(2 * np.pi)) * np.exp(-0.5 * ((x - b) / (a)) ** 2)
gauss_fun = lambda x, sigma, mu, a: a * np.exp(-0.5 * ((x - mu) ** 2 / sigma ** 2))
normalised_poisson_fun = lambda x, lam: ((lam ** x) * np.exp((-1) * lam)) / (np.math.factorial((x)))
poisson_fun = lambda x, lam, a: a * ((lam ** x) * np.exp((-1) * lam)) / (np.math.factorial((x)))

# This is the link between the function type and the LaTex description

func_type_text_list = [lin_fun_text, exp_fun_text, cos_fun_text, cos2_fun_text,
                       poly2_fun_text, poly3_fun_text,
                       normalised_gauss_fun_text, gauss_fun_text, normalised_poisson_fun, poisson_fun_text]

func_type_list = [lin_fun, exp_fun, cos_fun, cos2_fun,
                  poly2_fun, poly3_fun,
                  normalised_gauss_fun, gauss_fun, normalised_poisson_fun, poisson_fun]

func_type_text = lin_fun_text

func_type = lin_fun  # Choose which function you want to the graph to fit to

for i in range(len(func_type_text_list)):
    if func_type == func_type_list[i]:
        func_type_text = func_type_text_list[i]

# Initial parameter values:

a_0 = 0
b_0 = 0
a_limit_i = -1000
a_limit_f = 1000
b_limit_i = -1000
b_limit_f = 1000

# From here below everything is done automatically with an output of the graph.
# An area at the bottom is left to work with the variables generated from the graph, if needed.

# Reading Data

df = pd.read_excel(file_location, sheet_name=sheet_name)
x_data = df[x_column_name].values[x_start:x_stop]
y_data = df[y_column_name].values[x_start:x_stop]
dx = df[dx_column_name].values[x_start:x_stop]
dy = df[dy_column_name].values[x_start:x_stop]

# Sanity check to see if data is okay:

print("x data is:", x_data)
print("y data is:", y_data)
print("x errors are:", dx)
print("y errors are:", dy)


class EffVarChi2Reg:  # This class is like Chi2Regression but takes into account dx
    # This part defines the variables the class will use
    def __init__(self, model, x, y, dx, dy):
        self.model = model  # model predicts y value for given x value
        self.x = np.array(x)  # the x values
        self.y = np.array(y)  # the y values
        self.dx = np.array(dx)  # the x-axis uncertainties
        self.dy = np.array(dy)  # the y-axis uncertainties
        self.func_code = make_func_code(describe(self.model)[1:])
        self.h = (x[-1] - x[
            0]) / 10000000000000000000  # this is the step size for the numerical calculation of the df/dx = last value in x (x[-1]) - first value in x (x[0])/10000

    # This part defines the calculations when the function is called
    def __call__(self, *par):  # par are a variable number of model parameters
        self.ym = self.model(self.x, *par)
        df = (self.model(self.x + self.h,
                         *par) - self.ym) / self.h  # the derivative df/dx at point x is taken as [f(x+h)-f(x)]/h
        chi2 = sum(((self.y - self.ym) ** 2) / (self.dy ** 2 + (
                df * self.dx) ** 2))  # chi2 is now Sum of: f(x)-y)^2/(uncert_y^2+(df/dx*uncert_x)^2)
        return chi2

    # this part defines a function called "show" which will make a nice plot when invoked
    def show(self, optimizer, x_title="X", y_title="Y", goodness_loc=2):
        self.par = optimizer.parameters
        self.fit_arg = optimizer.fitarg
        self.chi2 = optimizer.fval
        self.ndof = len(self.x) - len(self.par)
        self.chi_ndof = self.chi2 / self.ndof
        self.par_values = []
        self.par_error = []
        text = "$ Fitted \  to \ y(x)={} $\n".format(func_type_text)
        for _ in (self.par):
            self.par_values.append(self.fit_arg[_])
            self.par_error.append(self.fit_arg["error_" + _])
            text += "$\ \ \ %s$ = %0.4f $\pm$ %0.4f \n" % (_, self.fit_arg[_], self.fit_arg["error_" + _])
        text = text + "$\dfrac{{\chi}^2}{N_{dof}} = %0.4f(%0.4f/%d)$\n" % (self.chi_ndof, self.chi2, self.ndof)
        self.func_x = np.linspace(self.x[0], self.x[-1], 10000)  # 10000 linearly spaced numbers
        self.y_fit = self.model(self.func_x, *self.par_values)
        plt.rc("font", size=16, family="Times New Roman")
        fig = plt.figure(figsize=(10, 6))
        ax = fig.add_axes([0, 0, 1, 1])
        ax.plot(self.func_x, self.y_fit)  # plot the function over 10k points covering the x axis
        ax.scatter(self.x, self.y, c="black")
        ax.errorbar(self.x, self.y, self.dy, self.dx, fmt='none', ecolor='red', capsize=3)
        ax.set_xlabel(x_title, fontdict={"size": 21})
        ax.set_ylabel(y_title, fontdict={"size": 21})
        anchored_text = AnchoredText(text, loc=box_location)
        ax.add_artist(anchored_text)
        plt.grid(True)


efvtest = EffVarChi2Reg(func_type, x_data, y_data, dx, dy)
efopt = Minuit(efvtest, a=a_0, b=b_0, limit_a=(a_limit_i, a_limit_f), limit_b=(b_limit_i, b_limit_f))
efopt.migrad()
number_param = len(list(efopt.args))
ndof = len(x_data) - number_param
chi2_ndof = efopt.fval / ndof
print("Chi2/ndof is %0.4f(%0.4f/%d)" % (chi2_ndof, efopt.fval, ndof))
efvtest.show(efopt, goodness_loc=4, x_title=x_label_title, y_title=y_label_title)
plt.title(main_title)
plt.savefig(graph_photo_name, dpi=300, bbox_inches='tight')
plt.show()

# Further calculations using the data generated from the graph:

a = efopt.np_values()[0]
a_err = efopt.np_errors()[0]
b = efopt.np_values()[1]
b_err = efopt.np_errors()[1]

print("slope is: ", a, ", slope error is :", a_err)
print("intercept is: ", b, ", intercept error is :", b_err)
